% =================================================================
% LEGAL AID DOMAIN RULES - CLOSED WORLD ASSUMPTION
% =================================================================

% =================================================================
% DYNAMIC PREDICATE DECLARATIONS
% =================================================================
% Declare income predicates as dynamic - they won't always be defined
:- discontiguous has_income/1.
:- discontiguous no_income/1.
:- dynamic has_income/1.
:- dynamic no_income/1.

% Other case-specific predicates that may vary
:- dynamic person/1.
:- dynamic social_category/2.
:- dynamic annual_income/2.
:- dynamic monthly_income/2.
:- dynamic vulnerable_group/2.
:- dynamic no_vulnerable_group/1.
:- dynamic gender/2.
:- dynamic age/2.

% =================================================================
% INCOME THRESHOLDS (Generated by Python, but fallbacks here)
% =================================================================
income_threshold(sc, 250000).       % ₹2.5 lakhs
income_threshold(st, 250000).       % ₹2.5 lakhs
income_threshold(obc, 220000).      % ₹2.2 lakhs
income_threshold(general, 180000).  % ₹1.8 lakhs
income_threshold(bpl, 0).           % Below Poverty Line - no threshold
income_threshold(ews, 250000).      % ₹2.5 lakhs

% =================================================================
% HELPER PREDICATES
% =================================================================

% Check if person's income is below threshold for their category
income_below_threshold(Person) :-
    annual_income(Person, Income),
    social_category(Person, Category),
    income_threshold(Category, Threshold),
    Income =< Threshold.

% =================================================================
% ELIGIBILITY RULES - ORDERED BY PRIORITY (CLOSED WORLD)
% =================================================================

% Priority 1: BPL category (Below Poverty Line) - Always eligible
eligible_with_confidence(Person, eligible, 0.95) :-
    social_category(Person, bpl), !.

% Priority 2: General category WITHOUT income information (assume eligible)
% ROBUST: Check both no_income fact AND negation of has_income
eligible_with_confidence(Person, eligible, 0.70) :-
    social_category(Person, general),
    (no_income(Person) ; \+ has_income(Person)), !.

% Priority 3: SC/ST/OBC categories without income info (assume eligible)
% ROBUST: Check both no_income fact AND negation of has_income
eligible_with_confidence(Person, eligible, 0.85) :-
    social_category(Person, Category),
    member(Category, [sc, st, obc]),
    (no_income(Person) ; \+ has_income(Person)), !.

% Priority 4: SC/ST/OBC categories with income below threshold
eligible_with_confidence(Person, eligible, 0.88) :-
    social_category(Person, Category),
    member(Category, [sc, st, obc]),
    income_below_threshold(Person), !.

% Priority 5: Vulnerable groups - Always eligible regardless of income
eligible_with_confidence(Person, eligible, 0.90) :-
    vulnerable_group(Person, _), !.

% Priority 6: General category with income below threshold
eligible_with_confidence(Person, eligible, 0.75) :-
    social_category(Person, general),
    income_below_threshold(Person), !.

% Priority 7: EWS category without income
% ROBUST: Check both no_income fact AND negation of has_income
eligible_with_confidence(Person, eligible, 0.78) :-
    social_category(Person, ews),
    (no_income(Person) ; \+ has_income(Person)), !.

% Priority 8: EWS category with income below threshold
eligible_with_confidence(Person, eligible, 0.80) :-
    social_category(Person, ews),
    income_below_threshold(Person), !.

% Default: Not eligible (income exceeds threshold or other disqualifying factors)
eligible_with_confidence(Person, not_eligible, 0.85) :-
    person(Person), !.

% Fallback for safety
eligible_with_confidence(_, not_eligible, 0.50).
vulnerable_group_eligible(Person) :- vulnerable_group(Person, single_parent).
vulnerable_group_eligible(Person) :- vulnerable_group(Person, transgender).

% =================================================================
% INCOME ELIGIBILITY WITH FALLBACKS
% =================================================================
income_eligible(Person) :-
    annual_income(Person, Income),
    integer(Income),
    social_category(Person, Category),
    income_threshold(Category, Threshold),
    Income =< Threshold, !.

% Fallback: If no income data exists, check if they're in a priority category
% =================================================================
% REASONING GENERATION
% =================================================================

generate_detailed_reasoning(Person, Reasoning) :-
    social_category(Person, Category),
    (   vulnerable_group(Person, VulnType) ->
        format(atom(Reasoning), 'Eligible as vulnerable group (~w) in ~w category', [VulnType, Category])
    ;   (no_income(Person) ; \+ has_income(Person)) ->
        format(atom(Reasoning), 'Eligible - no income information for ~w category', [Category])
    ;   annual_income(Person, Income), income_below_threshold(Person) ->
        format(atom(Reasoning), 'Eligible - income ~w below threshold for ~w category', [Income, Category])
    ;   annual_income(Person, Income) ->
        format(atom(Reasoning), 'Not eligible - income ~w exceeds threshold for ~w category', [Income, Category])
    ;   Reasoning = 'Default reasoning - insufficient information'
    ), !.

generate_detailed_reasoning(_, 'Unable to generate reasoning').

primary_eligibility_reason(Person, Reason) :-
    (   vulnerable_group(Person, _) ->
        Reason = 'Vulnerable group membership'
    ;   (no_income(Person) ; \+ has_income(Person)) ->
        Reason = 'No income information provided'
    ;   income_below_threshold(Person) ->
        Reason = 'Income below category threshold'
    ;   Reason = 'Does not meet eligibility criteria'
    ), !.

primary_eligibility_reason(_, 'Unknown').

% =================================================================
% OUTPUT HELPERS - CRITICAL FOR PYTHON INTEGRATION
% =================================================================

% Print eligibility result in Python-parseable format
print_eligibility(Person) :-
    eligible_with_confidence(Person, Eligible, Confidence),
    write('Eligible = '), write(Eligible), write(', '),
    write('Confidence = '), write(Confidence), nl,
    !.

print_eligibility(Person) :-
    % If no rule matches, default to not eligible
    write('Eligible = not_eligible, Confidence = 0.30'), nl.

% Print detailed reasoning
print_detailed_reasoning(Person) :-
    generate_detailed_reasoning(Person, DetailedReason),
    write('DetailedReason = '), write(DetailedReason), nl,
    !.

print_detailed_reasoning(_) :-
    write('DetailedReason = No detailed reasoning available'), nl.

% Print primary reason
print_primary_reason(Person) :-
    primary_eligibility_reason(Person, Reason),
    write('Reason = '), write(Reason), nl,
    !.

print_primary_reason(_) :-
    write('Reason = No reason determined'), nl.

% =================================================================
% PYTHON INTEGRATION OUTPUT WRAPPER
% =================================================================

% CRITICAL: This must call eligible_with_confidence and print its EXACT output
check_and_print_eligibility(Person) :-
    eligible_with_confidence(Person, Eligible, Confidence),
    !,  % Cut to prevent backtracking
    writeln(Eligible),
    writeln(Confidence).

% Fallback if no rule matches (should rarely happen)
check_and_print_eligibility(_) :-
    writeln(not_eligible),
    writeln(0.30).
